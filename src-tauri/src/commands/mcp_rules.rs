use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs;
use std::path::PathBuf;
use reqwest;
use serde_json::json;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TransportType {
    #[serde(rename = "type")]
    pub transport_type: String,
    pub command: String,
    pub args: Vec<String>,
    pub env: Option<HashMap<String, String>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MCPService {
    pub name: String,
    pub title: String,
    pub transport_type: TransportType,
    pub uuid: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cached_at: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RuleMemory {
    pub name: String,
    pub content: String,
    #[serde(default)]
    pub is_autogenerated: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Rule {
    pub name: String,
    pub title: String,
    pub memory: RuleMemory,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cached_at: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MCPRuleCache {
    pub mcp_services: HashMap<String, MCPService>,
    pub rules: HashMap<String, Rule>,
    pub last_sync: Option<String>,
    pub current_account: Option<String>,
}

impl Default for MCPRuleCache {
    fn default() -> Self {
        Self {
            mcp_services: HashMap::new(),
            rules: HashMap::new(),
            last_sync: None,
            current_account: None,
        }
    }
}

fn get_cache_path() -> PathBuf {
    let app_dir = dirs::data_local_dir()
        .unwrap_or_else(|| PathBuf::from("."))
        .join("warp-plus");
    
    fs::create_dir_all(&app_dir).ok();
    app_dir.join("mcp_rules_cache.json")
}

fn load_cache() -> Result<MCPRuleCache, String> {
    let path = get_cache_path();
    if !path.exists() {
        return Ok(MCPRuleCache::default());
    }

    let content = fs::read_to_string(&path)
        .map_err(|e| format!("读取缓存失败: {}", e))?;
    
    serde_json::from_str(&content)
        .map_err(|e| format!("解析缓存失败: {}", e))
}

fn save_cache(cache: &MCPRuleCache) -> Result<(), String> {
    let path = get_cache_path();
    let content = serde_json::to_string_pretty(cache)
        .map_err(|e| format!("序列化缓存失败: {}", e))?;
    
    fs::write(&path, content)
        .map_err(|e| format!("写入缓存失败: {}", e))
}

/// 获取所有 MCP 服务
#[tauri::command]
pub async fn get_mcp_services() -> Result<Vec<MCPService>, String> {
    let cache = load_cache()?;
    Ok(cache.mcp_services.values().cloned().collect())
}

/// 获取所有规则
#[tauri::command]
pub async fn get_rules() -> Result<Vec<Rule>, String> {
    let cache = load_cache()?;
    Ok(cache.rules.values().cloned().collect())
}

/// 添加或更新 MCP 服务
#[tauri::command]
pub async fn save_mcp_service(service: MCPService) -> Result<(), String> {
    let mut cache = load_cache()?;
    cache.mcp_services.insert(service.name.clone(), service);
    cache.last_sync = Some(chrono::Utc::now().to_rfc3339());
    save_cache(&cache)
}

/// 添加或更新规则
#[tauri::command]
pub async fn save_rule(rule: Rule) -> Result<(), String> {
    let mut cache = load_cache()?;
    cache.rules.insert(rule.name.clone(), rule);
    cache.last_sync = Some(chrono::Utc::now().to_rfc3339());
    save_cache(&cache)
}

/// 删除 MCP 服务
#[tauri::command]
pub async fn delete_mcp_service(name: String) -> Result<(), String> {
    let mut cache = load_cache()?;
    cache.mcp_services.remove(&name);
    cache.last_sync = Some(chrono::Utc::now().to_rfc3339());
    save_cache(&cache)
}

/// 删除规则
#[tauri::command]
pub async fn delete_rule(name: String) -> Result<(), String> {
    let mut cache = load_cache()?;
    cache.rules.remove(&name);
    cache.last_sync = Some(chrono::Utc::now().to_rfc3339());
    save_cache(&cache)
}

/// 获取缓存摘要
#[tauri::command]
pub async fn get_cache_summary() -> Result<serde_json::Value, String> {
    let cache = load_cache()?;
    Ok(serde_json::json!({
        "mcp_count": cache.mcp_services.len(),
        "rule_count": cache.rules.len(),
        "last_sync": cache.last_sync,
        "current_account": cache.current_account,
    }))
}

const WARP_GRAPHQL_URL: &str = "https://app.warp.dev/graphql/v2";
const CLIENT_VERSION: &str = "v0.2025.09.24.08.11.stable_03";

#[derive(Debug, Serialize)]
struct GraphQLRequest {
    query: String,
    variables: serde_json::Value,
    #[serde(rename = "operationName")]
    operation_name: String,
}

/// 从云端同步 MCP 和规则
#[tauri::command]
pub async fn sync_from_cloud(token: String) -> Result<String, String> {
    let query = r#"
        query GetUpdatedCloudObjects($input: UpdatedCloudObjectsInput!, $requestContext: RequestContext!) {
          updatedCloudObjects(input: $input, requestContext: $requestContext) {
            __typename
            ... on UpdatedCloudObjectsOutput {
              genericStringObjects {
                format
                metadata { uid }
                serializedModel
              }
            }
          }
        }
    "#;

    let variables = json!({
        "input": {
            "genericStringObjects": [],
            "forceRefresh": true
        },
        "requestContext": {
            "clientContext": {"version": CLIENT_VERSION},
            "osContext": {"category": "Windows", "name": "Windows", "version": "10"}
        }
    });

    let client = reqwest::Client::new();
    let response = client
        .post(format!("{}?op=GetUpdatedCloudObjects", WARP_GRAPHQL_URL))
        .header("Authorization", format!("Bearer {}", token))
        .header("Content-Type", "application/json")
        .json(&GraphQLRequest {
            query: query.to_string(),
            variables,
            operation_name: "GetUpdatedCloudObjects".to_string(),
        })
        .send()
        .await
        .map_err(|e| format!("请求失败: {}", e))?;

    let result: serde_json::Value = response
        .json()
        .await
        .map_err(|e| format!("解析响应失败: {}", e))?;

    // 解析云端数据
    let objects = result
        .get("data")
        .and_then(|d| d.get("updatedCloudObjects"))
        .and_then(|u| u.get("genericStringObjects"))
        .and_then(|g| g.as_array())
        .ok_or("无效的响应格式")?;

    let mut cache = load_cache()?;
    let mut mcp_count = 0;
    let mut rule_count = 0;

    for obj in objects {
        let format = obj.get("format").and_then(|f| f.as_str()).unwrap_or("");
        let serialized = obj.get("serializedModel").and_then(|s| s.as_str()).unwrap_or("{}");
        
        if let Ok(model) = serde_json::from_str::<serde_json::Value>(serialized) {
            match format {
                "JsonMCPServer" => {
                    if let Ok(mcp) = serde_json::from_value::<MCPService>(model.clone()) {
                        cache.mcp_services.insert(mcp.name.clone(), mcp);
                        mcp_count += 1;
                    }
                }
                "JsonAIFact" => {
                    if let Some(memory) = model.get("memory") {
                        if let (Some(name), Some(content)) = (
                            memory.get("name").and_then(|n| n.as_str()),
                            memory.get("content").and_then(|c| c.as_str()),
                        ) {
                            let rule = Rule {
                                name: name.to_string(),
                                title: name.to_string(),
                                memory: RuleMemory {
                                    name: name.to_string(),
                                    content: content.to_string(),
                                    is_autogenerated: memory
                                        .get("is_autogenerated")
                                        .and_then(|a| a.as_bool())
                                        .unwrap_or(false),
                                },
                                cached_at: Some(chrono::Utc::now().to_rfc3339()),
                            };
                            cache.rules.insert(rule.name.clone(), rule);
                            rule_count += 1;
                        }
                    }
                }
                _ => {}
            }
        }
    }

    cache.last_sync = Some(chrono::Utc::now().to_rfc3339());
    save_cache(&cache)?;

    Ok(format!("同步成功：{} 个 MCP 服务，{} 条规则", mcp_count, rule_count))
}

/// 上传 MCP 服务到云端
#[tauri::command]
pub async fn upload_mcp_to_cloud(token: String, user_id: String, service: MCPService) -> Result<String, String> {
    let query = r#"
        mutation CreateGenericStringObject($input: CreateGenericStringObjectInput!, $requestContext: RequestContext!) {
          createGenericStringObject(input: $input, requestContext: $requestContext) {
            __typename
            ... on CreateGenericStringObjectOutput {
              genericStringObject { metadata { uid } format }
            }
            ... on UserFacingError { error { __typename message } }
          }
        }
    "#;

    // 构建 Warp 期望的 transport_type 格式
    let transport_type = json!({
        "CLIServer": {
            "command": service.transport_type.command,
            "args": service.transport_type.args,
            "cwd_parameter": null,
            "static_env_vars": service.transport_type.env.unwrap_or_default()
                .into_iter()
                .map(|(k, v)| {
                    if v.is_empty() {
                        json!({"name": k})
                    } else {
                        json!({"name": k, "value": v})
                    }
                })
                .collect::<Vec<_>>()
        }
    });

    let serialized_model = json!({
        "transport_type": transport_type,
        "name": service.name,
        "uuid": service.uuid,
    });

    let timestamp = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap()
        .as_micros();

    let variables = json!({
        "input": {
            "genericStringObject": {
                "clientId": format!("Client-{}", timestamp),
                "entrypoint": "Unknown",
                "format": "JsonMCPServer",
                "initialFolderId": null,
                "serializedModel": serde_json::to_string(&serialized_model).unwrap(),
                "uniquenessKey": null
            },
            "owner": {
                "uid": user_id,
                "type": "User"
            }
        },
        "requestContext": {
            "clientContext": {"version": CLIENT_VERSION},
            "osContext": {"category": "Windows", "name": "Windows", "version": "10"}
        }
    });

    let client = reqwest::Client::new();
    let response = client
        .post(format!("{}?op=CreateGenericStringObject", WARP_GRAPHQL_URL))
        .header("Authorization", format!("Bearer {}", token))
        .header("Content-Type", "application/json")
        .header("x-warp-client-version", CLIENT_VERSION)
        .header("x-warp-os-category", "Windows")
        .header("x-warp-os-name", "Windows")
        .header("x-warp-os-version", "10")
        .json(&GraphQLRequest {
            query: query.to_string(),
            variables,
            operation_name: "CreateGenericStringObject".to_string(),
        })
        .send()
        .await
        .map_err(|e| format!("上传失败: {}", e))?;

    let status = response.status();
    let result: serde_json::Value = response
        .json()
        .await
        .map_err(|e| format!("解析响应失败: {}", e))?;

    // 检查是否有错误
    if let Some(errors) = result.get("errors") {
        return Err(format!("GraphQL 错误: {}", errors));
    }

    // 检查是否有 UserFacingError
    if let Some(data) = result.get("data") {
        if let Some(create_obj) = data.get("createGenericStringObject") {
            if let Some(error) = create_obj.get("error") {
                let err_msg = error.get("message")
                    .and_then(|m| m.as_str())
                    .unwrap_or("未知错误");
                return Err(format!("Warp API 错误: {}", err_msg));
            }
        }
    }

    if status.is_success() {
        Ok("MCP 服务已上传到云端".to_string())
    } else {
        Err(format!("上传失败: HTTP {} - {}", status, result))
    }
}

/// 自动获取 token 并上传 MCP 服务
#[tauri::command]
pub async fn upload_mcp_auto(service: MCPService) -> Result<String, String> {
    use crate::commands::warp_token::{get_warp_user_info, refresh_access_token};
    
    // 1. 获取用户信息
    let user_info = get_warp_user_info().await?;
    
    // 2. 刷新获取 access_token
    let token_response = refresh_access_token(user_info.id_token.refresh_token).await?;
    
    // 3. 上传到云端
    upload_mcp_to_cloud(token_response.access_token, user_info.local_id, service).await
}

/// 自动获取 token 并上传规则
#[tauri::command]
pub async fn upload_rule_auto(rule: Rule) -> Result<String, String> {
    use crate::commands::warp_token::{get_warp_user_info, refresh_access_token};
    
    // 1. 获取用户信息
    let user_info = get_warp_user_info().await?;
    
    // 2. 刷新获取 access_token
    let token_response = refresh_access_token(user_info.id_token.refresh_token).await?;
    
    // 3. 上传到云端
    upload_rule_to_cloud(token_response.access_token, user_info.local_id, rule).await
}

/// 上传规则到云端
#[tauri::command]
pub async fn upload_rule_to_cloud(token: String, user_id: String, rule: Rule) -> Result<String, String> {
    let query = r#"
        mutation CreateGenericStringObject($input: CreateGenericStringObjectInput!, $requestContext: RequestContext!) {
          createGenericStringObject(input: $input, requestContext: $requestContext) {
            __typename
            ... on CreateGenericStringObjectOutput {
              genericStringObject { metadata { uid } format }
            }
            ... on UserFacingError { error { __typename message } }
          }
        }
    "#;

    let serialized_model = json!({
        "memory": {
            "name": rule.memory.name,
            "content": rule.memory.content,
            "is_autogenerated": rule.memory.is_autogenerated,
        }
    });

    let timestamp = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap()
        .as_micros();

    let variables = json!({
        "input": {
            "genericStringObject": {
                "clientId": format!("Client-{}", timestamp),
                "entrypoint": "Unknown",
                "format": "JsonAIFact",
                "initialFolderId": null,
                "serializedModel": serde_json::to_string(&serialized_model).unwrap(),
                "uniquenessKey": null
            },
            "owner": {
                "uid": user_id,
                "type": "User"
            }
        },
        "requestContext": {
            "clientContext": {"version": CLIENT_VERSION},
            "osContext": {"category": "Windows", "name": "Windows", "version": "10"}
        }
    });

    let client = reqwest::Client::new();
    let response = client
        .post(format!("{}?op=CreateGenericStringObject", WARP_GRAPHQL_URL))
        .header("Authorization", format!("Bearer {}", token))
        .header("Content-Type", "application/json")
        .json(&GraphQLRequest {
            query: query.to_string(),
            variables,
            operation_name: "CreateGenericStringObject".to_string(),
        })
        .send()
        .await
        .map_err(|e| format!("上传失败: {}", e))?;

    if response.status().is_success() {
        Ok("规则已上传到云端".to_string())
    } else {
        Err(format!("上传失败: HTTP {}", response.status()))
    }
}
